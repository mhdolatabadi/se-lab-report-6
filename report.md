## سوال اول:

الگوهای ساخت (Creational Patterns): این الگوها به نحوه ایجاد اشیاء و نمونه‌های کلاس‌ها می‌پردازند و هدفشان جداسازی
فرآیند
ایجاد از کدهایی است که از اشیاء استفاده می‌کنند. مثال‌های معروف شامل Singleton و Factory Method هستند.

الگوهای ساختاری (Structural Patterns): این الگوها به نحوه ترکیب و سازماندهی کلاس‌ها و اشیاء برای تشکیل ساختارهای بزرگ‌تر
می‌پردازند. هدفشان تسهیل ایجاد ساختارهای پیچیده و انعطاف‌پذیر است. نمونه‌هایی از این الگوها شامل Adapter و Composite
هستند.

الگوهای رفتاری (Behavioral Patterns): این الگوها بر روی تعامل و مسئولیت‌های بین اشیاء تمرکز دارند و هدفشان بهبود
انعطاف‌پذیری و ارتباطات بین اشیاء است. الگوهایی نظیر Observer و Strategy از جمله این دسته هستند.

## سوال چهارم:

در الگوی طراحی Singleton، اصول SOLID به شرح زیر تحقق یا عدم تحقق می‌یابند:

**Single Responsibility Principle (SRP):** به طور کلی، الگوی Singleton می‌تواند در این زمینه مشکلی ایجاد کند، زیرا
کلاس Singleton معمولاً مسئولیت ایجاد و مدیریت تنها یک نمونه از خود را بر عهده دارد. این ممکن است باعث اختلاط
مسئولیت‌ها شود اگر کلاس مورد نظر وظایف دیگری نیز داشته باشد.

**Open/Closed Principle (OCP):** الگوی Singleton به طور معمول از این اصل پیروی نمی‌کند، زیرا برای تغییر رفتار
Singleton باید کد کلاس را تغییر داد. این الگو به صورت پیش‌فرض بسته به تغییر و باز به گسترش نیست.

**Liskov Substitution Principle (LSP):** الگوی Singleton ممکن است این اصل را نقض کند، زیرا نمی‌توان به راحتی کلاس
Singleton را با زیرکلاس‌های آن جایگزین کرد. زیرکلاس‌ها نمی‌توانند به درستی ویژگی‌های Singleton را حفظ کنند.

**Interface Segregation Principle (ISP):** این اصل به خوبی در Singleton رعایت می‌شود، زیرا کلاس Singleton معمولاً
رابط‌های کوچک و مشخصی دارد که نیازی به تقسیم شدن به رابط‌های دیگر نیست. لذا، استفاده‌کنندگان فقط به رابط‌های مورد
نیاز خود دسترسی دارند.

**Dependency Inversion Principle (DIP):** الگوی Singleton معمولاً این اصل را نقض می‌کند، زیرا وابستگی‌ها به طور
مستقیم به یک کلاس Singleton تزریق می‌شود و این باعث می‌شود که وابستگی‌ها به سطح پایین و خاصی وابسته باشند، که اصول
DIP را رعایت نمی‌کند.

## سوال پنجم

. **کد تمیز:** کد تمیز کدی است که خوانا، ساده و قابل نگهداری است و اصول طراحی خوب را رعایت می‌کند.

. **بدهی فنی:** بدهی فنی به مشکلات و کاستی‌های موجود در کد اشاره دارد که ممکن است به دلیل تصمیمات طراحی سریع یا غیر
بهینه ایجاد شده باشد و نیاز به اصلاح و بهبود در آینده دارد.

. **بوی بد:** بوی بد (Code Smell) به نشانه‌هایی در کد اشاره دارد که نشان‌دهنده مشکلات بالقوه طراحی یا کیفیت پایین کد
هستند و نیاز به بررسی و اصلاح دارند.

## سوال ششم

طبق دسته‌بندی وب‌سایت refactoring.guru، بوهای بد کد به پنج دسته اصلی تقسیم می‌شوند که شامل موارد زیر هستند:

. **کد تکراری (Duplicate Code):** شامل بخش‌هایی از کد است که به طور مکرر در برنامه تکرار شده‌اند، که می‌تواند باعث
مشکلاتی در نگهداری و تغییرات آتی شود. این مسئله معمولاً با استخراج کد تکراری به متدهای مشترک حل می‌شود.

. **اشیاء و کلاس‌های بزرگ (Large Classes and Methods):** شامل کلاس‌ها یا متدهایی است که بیش از حد بزرگ و پیچیده شده‌اند،
که می‌تواند باعث کاهش خوانایی و سختی در نگهداری و تغییر آن‌ها شود. راه‌حل‌های معمول شامل تقسیم کلاس‌ها و متدها به
بخش‌های کوچکتر است.

. **پدیده‌های نامناسب (Poor Naming):** به استفاده از نام‌های مبهم، نامشخص یا نادرست برای متغیرها، کلاس‌ها، و متدها اشاره
دارد که می‌تواند فهم و نگهداری کد را دشوار کند. استفاده از نام‌های توصیفی و معنادار یکی از راه‌های بهبود این مشکل است.

. **وابستگی‌های زیاد (Excessive Dependencies):** شامل وابستگی‌های پیچیده و زیاد بین کلاس‌ها یا ماژول‌ها است که می‌تواند
موجب افزایش پیچیدگی و مشکلات در تغییرات کد شود. کاهش وابستگی‌ها و استفاده از اصول طراحی مناسب می‌تواند به کاهش این مشکل
کمک کند.

. **ساختارهای پیچیده (Complex Structures):** به ساختارهای پیچیده و غیر ضروری در کد اشاره دارد که می‌تواند فهم و تغییرات
را دشوار کند. ساده‌سازی ساختارها و استفاده از طراحی‌های واضح و قابل فهم راه‌حل‌هایی برای این مسئله هستند.

## سوال هفتم

**بوی بد Lazy Class** در دسته‌بندی **اشیاء و کلاس‌های بزرگ** (Large Classes and Methods) قرار می‌گیرد.

### برای برطرف‌کردن این بو، استفاده از کدام بازآرایی‌ها پیشنهاد می‌شود؟

برای برطرف‌کردن بوی بد Lazy Class، می‌توان از بازآرایی‌های زیر استفاده کرد:

. **درهم‌آمیختن رفتارها (Move Methods):** اگر کلاس فقط مقدار کمی از رفتار را ارائه می‌دهد، می‌توان متدهای آن را به
کلاس‌های دیگر منتقل کرد که مسئولیت بیشتری دارند.

. **ادغام (Inline Class):** اگر کلاس بسیار کوچک است و فقط شامل چند متد و داده است، می‌توان آن را به کلاس دیگری که نیاز
به آن دارد، ادغام کرد.

. **تفکیک (Extract Class):** اگر کلاس دارای رفتارهای مختلف و غیر مرتبط است، می‌توان آن را به چند کلاس با مسئولیت‌های
واضح‌تر تقسیم کرد.

### در چه مواقعی باید این بو را نادیده گرفت؟

بوی بد Lazy Class را می‌توان در موارد زیر نادیده گرفت:

. **پیشرفت‌های آتی:** اگر کلاس کوچک و ساده است و در حال حاضر رفتار خاصی ندارد، اما ممکن است در آینده گسترش یابد و
ویژگی‌های جدیدی به آن افزوده شود، نادیده گرفتن آن منطقی است.

. **سادگی و خوانایی:** اگر نادیده گرفتن این بو باعث حفظ سادگی و خوانایی کد می‌شود و به بهبود درک و نگهداری کد کمک
می‌کند، می‌توان این بو را نادیده گرفت.

. **ملاحظات طراحی:** در برخی مواقع، پیاده‌سازی موقت یا طراحی ساده به نفع سرعت توسعه و عدم پیچیدگی فوری است، و ممکن است
نیاز به بازآرایی در آینده با توجه به تغییرات پروژه باشد.

## سوال نهم

**پلاگین Formatter** ابزار یا افزونه‌ای است که به طور خودکار کد منبع را بر اساس قواعد و استانداردهای خاصی قالب‌بندی
می‌کند. این قواعد شامل فاصله‌گذاری، فاصله بین خطوط، ترتیب و نام‌گذاری متغیرها و متدها، و دیگر قوانین سبک کد هستند.

### چرا می‌تواند کمک‌کننده باشد؟

. **یکنواختی:** Formatter به ایجاد کد منسجم و یکنواخت کمک می‌کند که خوانایی و نگهداری کد را آسان‌تر می‌کند.

. **کاهش اشتباهات:** با اعمال قواعد مشخص و ثابت، formatter احتمال بروز اشتباهات ناشی از سبک‌های نامنظم و ناهماهنگ را
کاهش می‌دهد.

. **افزایش بهره‌وری:** با خودکارسازی فرآیند قالب‌بندی، زمان توسعه‌دهندگان صرف تنظیمات دستی و تصحیحات فرمت نمی‌شود و
می‌توانند بر روی منطق و عملکرد کد تمرکز کنند.

### رابطه آن با بازآرایی کد چیست؟

Formatter به طور مستقیم به بازآرایی کد مربوط نمی‌شود، زیرا بازآرایی (Refactoring) به تغییر ساختار و طراحی کد برای بهبود
کیفیت و عملکرد آن اشاره دارد، در حالی که formatter فقط به قالب‌بندی و ظاهر کد می‌پردازد. با این حال، استفاده از
formatter می‌تواند به بهبود کیفیت کد کمک کند زیرا:

. **خوانایی:** کد تمیز و منظم باعث می‌شود که تحلیل و بازآرایی‌های بعدی راحت‌تر و دقیق‌تر انجام شود.

. **تمرکز بر منطق:** با حذف مشکلات قالب‌بندی، توسعه‌دهندگان می‌توانند بیشتر بر روی تغییرات ساختاری و بهبودهای عملکردی
تمرکز کنند.
